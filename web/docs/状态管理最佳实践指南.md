# 状态管理最佳实践指南

## 1. 核心理念：分离关注点

在现代 React 应用中，我们将状态分为两类，并分别使用专门的工具进行管理。**核心原则是：Server State 属于 React Query，Client State 属于 Zustand。**

| 状态类型         | 定义                                                         | 最佳工具                         | 示例                                              |
| :--------------- | :----------------------------------------------------------- | :------------------------------- | :------------------------------------------------ |
| **Server State** | 来自服务器的数据，具有异步性质，需要缓存、更新、去重。       | **TanStack Query (React Query)** | 用户信息、简历列表、文章数据                      |
| **Client State** | 仅存在于浏览器中的 UI 状态，通常是同步的，用于控制界面展示。 | **Zustand**                      | 侧边栏开关、弹窗显示、列表/网格视图切换、暗黑模式 |

---

## 2. Server State 管理 (TanStack Query)

我们不再将 API 数据存储在 Redux 或 Zustand 全局 Store 中，而是将 "获取数据" 这一行为交给 React Query。

### 2.1 "QueryKey" 即 Global Store ID

在 TanStack Query 中，`QueryKey` 就是状态的唯一标识符，类似于 Redux 中的 Store Key。

- **自动共享**: 任何组件只要使用相同的 `queryKey` 调用 `useQuery`，它们就会自动共享同一份缓存数据。
- **思维转变**: 不再需要显式创建全局 Store 来共享 API 数据，`QueryKey` 就是隐式的 Store ID。

### 2.2 目录结构与管理

使用常量对象（Factory Pattern）管理 Query Keys，方便统一管理 cache invalidation。

```typescript
// src/queries/useUserQueries.ts
export const USER_KEYS = {
  all: ['users'] as const,
  currentUser: ['currentUser'] as const,
  byId: (id: string) => ['users', id] as const,
};

// 自定义 Hook 封装 ("Pull, Don't Push")
export function useCurrentUser() {
  return useQuery({
    queryKey: USER_KEYS.currentUser,
    queryFn: fetchUserProfile,
    staleTime: 1000 * 60 * 5,
  });
}
```

### 2.3 最佳实践：混合模式 (The "Hybrid" Approach)

- **Pull, Don't Push**: 组件应该主动"拉取"所需数据（使用 hooks），而不是获取数据后手动"推送"到 Zustand store。
- **避免手动同步**: **切勿**编写 `useEffect` 监听 query data 然后 `setZustandStore`。这会导致"双重数据源"和同步 Bug。如果需要从 Store 访问 Query 数据，应重新审视架构，或者直接在组件中使用 Query Hook。

---

## 3. Client State 管理 (Zustand)

Zustand 仅用于管理轻量级的、跨组件的 UI 状态，或者 **Server State 无法覆盖的临时状态**。

### 3.1 Store 设计

Store 应该非常纯粹，**不包含** API 调用逻辑。

```typescript
// src/store/useResumeStore.ts
interface ResumeState {
  viewMode: 'grid' | 'list'; // 纯 UI 状态
  setViewMode: (mode: 'grid' | 'list') => void;
}
```

### 3.2 何时引入 Zustand？

1.  **纯 UI 设置**: 主题、侧边栏、过滤器状态。
2.  **跨组件的临时 Session 数据**: 例如多步表单（Wizard），第一步提交的数据还没存到服务器，但第二步需要用到。这也是 **最佳实践**：在 Mutation 的 `onSuccess` 中将临时数据存入 Zustand。

---

## 4. 处理变更 (Mutations & Actions)

### 4.1 Mutation 作为"桥梁"

虽然 `useMutation` 不缓存数据，但它是连接 Server State 和 Client State 的桥梁。

- **Invalidation (Server State 更新)**: Mutation 成功后，通过 `queryClient.invalidateQueries` 标记 Server State 为"脏"，触发自动重新获取。这是更新 Server State 的标准方式。

```typescript
const mutation = useMutation({
  mutationFn: updateUser,
  onSuccess: () => {
    // 告诉 React Query："用户列表过期了，去重新拉取一下"
    queryClient.invalidateQueries({ queryKey: USER_KEYS.all });
  },
});
```

### 4.2 `mutateAsync` 用于线性逻辑

当需要执行一个操作并立即跳转或进行 UI 变换时，推荐使用 `mutateAsync` 配合 `async/await`。 React Query 保证 `onSuccess` 会在 `await` 解析前执行完毕，确保数据一致性。

```typescript
const handleSubmit = async () => {
  // 等待 mutating 完成，且 onSuccess (如存临时 token 到 store) 也执行完毕
  await loginMutation.mutateAsync(formData);
  // 安全跳转
  navigate('/dashboard');
};
```

---

## 5. 持久化策略 (Persistence)

默认情况下，Web 应用刷新后状态重置是合理的。但如果需要持久化：

### 5.1 React Query Persistence

使用 `persistQueryClient` 可以将 Server State 缓存到 localStorage。

- **原则**: 只持久化低频变动的数据（如用户信息、配置）。
- **注意**: 敏感数据（Token）不要持久化到不安全的地方；注意浏览器存储容量限制。

### 5.2 Zustand Persistence

使用 `persist` 中间件持久化 UI 偏好。

- **原则**: 只持久化用户偏好（如 `viewMode`, `theme`）。

---

## 6. 总结：决策树

1.  **数据来自 API？** -> **React Query** (Server State)
2.  **数据只是 UI 状态（开关/视图）？** -> **Zustand** (Client State)
3.  **数据是多步操作中的临时产物？** -> **Zustand** (但最终通过 Mutation 提交给 Server)
4.  **需要数据在多个组件共享？**
    - 如果是 API 数据 -> 使用相同的 `QueryKey`。
    - 如果是 UI 状态 -> 使用 Zustand Store。

---

_文档更新日期: 2026-01-25_
