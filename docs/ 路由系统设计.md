# React 路由系统设计文档

本文档详细说明了本项目中的路由实现方案。本项目采用 **React Router v6** 进行单页应用（SPA）的路由管理，并使用了**集中式路由配置**的最佳实践。

## 1. 技术选型

### 核心依赖

我们在 `package.json` 中引入了以下依赖：

- **`react-router-dom`**: 包含了 React Router 的核心逻辑以及 DOM 绑定（`<BrowserRouter>`, `<Link>` 等）。这是 Web 应用必须的。
- **`react-router`**: React Router 的核心库。虽然 `react-router-dom` 已经重新导出了核心功能，但为了明确依赖关系或兼容某些非 DOM 环境的逻辑复用，我们将其显式安装。

## 2. 目录结构

我们在 `src` 目录下采用了模块化的结构来组织路由相关代码：

```
src/
├── layouts/          # 布局组件
│   └── MainLayout.tsx # 包含顶部导航栏的主布局
├── pages/            # 页面组件
│   ├── Home.tsx      # 首页
│   ├── Resume.tsx    # 我的简历
│   ├── Analysis.tsx  # 简历分析
│   └── Discover.tsx  # 发现
├── router/           # 路由配置
│   └── index.tsx     # 集中式路由定义
└── App.tsx           # 应用入口，注入 Provider
```

## 3. 实现细节

### 3.1 集中式路由配置 (`src/router/index.tsx`)

我们放弃了传统的 JSX 组件式路由定义（即 `<Routes><Route ... /></Routes>`），转而使用 v6 推荐的 **Data API** (`createBrowserRouter`)。这种方式更利于 Typescript 类型推导，并支持未来扩展 Loader 和 Action 等数据特性。

```tsx
import { createBrowserRouter } from 'react-router-dom';
import MainLayout from '../layouts/MainLayout';
// ... 导入页面组件

const router = createBrowserRouter([
  {
    path: '/',
    element: <MainLayout />, // 使用布局通常作为父路由
    children: [
      {
        index: true, // 默认子路由 (对应 path: '/')
        element: <Home />,
      },
      {
        path: 'resume',
        element: <Resume />,
      },
      // ... 其他路由
    ],
  },
]);

export default router;
```

### 3.2 布局与插槽 (`src/layouts/MainLayout.tsx`)

`MainLayout` 利用了 **`Outlet`** 组件来渲染匹配到的子路由内容。这是嵌套路由的核心。

```tsx
import { Outlet } from 'react-router';
import { NavLink } from 'react-router-dom';

export default function MainLayout() {
  return (
    <div>
      <nav>
        {/* NavLink 提供了 isActive 属性，方便设置高亮样式 */}
        <NavLink to="/" className={({ isActive }) => (...) }>Home</NavLink>
        <NavLink to="/resume" ... >My Resume</NavLink>
      </nav>

      <main>
        {/* 子路由页面将在这里渲染 */}
        <Outlet />
      </main>
    </div>
  );
}
```

### 3.3 应用入口注入 (`src/App.tsx`)

在根组件中，我们不再直接写路由逻辑，而是使用 `RouterProvider` 将配置好的 `router` 注入应用。

```tsx
import { RouterProvider } from 'react-router-dom';
import router from './router';

function App() {
  return <RouterProvider router={router} />;
}
```

## 4. 性能优化：懒加载与 Suspense

### 4.1 为什么需要懒加载？

在传统的导入方式下，所有页面组件都会被打包到同一个 bundle 中：

```tsx
import Home from '../pages/Home';
import Resume from '../pages/Resume';
// 所有页面都会在初始加载时下载
```

这会导致：

- **初始加载时间长**：用户可能只访问首页，却下载了所有页面的代码
- **首屏渲染慢**：浏览器需要解析更多 JavaScript

### 4.2 懒加载实现

使用 `React.lazy()` 实现按需加载：

```tsx
import { lazy, Suspense } from 'react';

// 懒加载：只在访问时才下载对应页面的代码
const Home = lazy(() => import('../pages/Home'));
const Resume = lazy(() => import('../pages/Resume'));
```

**工作原理**：

1. 初始加载时，只下载路由配置和布局组件
2. 用户访问 `/resume` 时，才动态下载 `Resume.tsx` 及其依赖
3. Webpack/Vite 会自动将每个懒加载组件打包成独立的 chunk

### 4.3 Suspense 边界

懒加载的组件需要用 `<Suspense>` 包裹，提供加载时的 fallback UI：

```tsx
const loadingFallback = (
  <div className="flex items-center justify-center min-h-[60vh]">
    <div className="text-center">
      <div className="spinner"></div>
      <p>Loading...</p>
    </div>
  </div>
);

const withSuspense = (Component: React.ComponentType) => (
  <Suspense fallback={loadingFallback}>
    <Component />
  </Suspense>
);
```

**注意事项**：

- `fallback` 必须是一个 React 元素，不能是组件函数（避免 Fast Refresh 警告）
- Loading UI 应该提供良好的用户体验（加载动画、骨架屏等）

### 4.4 性能收益

通过懒加载，我们实现了：

- **代码分割（Code Splitting）**：每个页面独立打包
- **按需加载（On-Demand Loading）**：只下载当前需要的代码
- **更快的首屏加载**：初始 bundle 体积显著减小

**示例**：

```
传统方式：
- main.js: 500KB (包含所有页面)

懒加载后：
- main.js: 100KB (只包含布局和路由)
- Home.chunk.js: 50KB
- Resume.chunk.js: 80KB
- Analysis.chunk.js: 120KB
- Discover.chunk.js: 150KB
```

用户访问首页时，只需下载 150KB，而不是 500KB。

## 5. 为什么选择这种方案？

1.  **关注点分离**：路由配置与组件渲染分离，维护 `router/index.tsx` 即可管理所有路径，类似 Vue 的 `vue-router` 体验。
2.  **布局嵌套**：通过 `Layout` + `Outlet` 模式，轻松实现全局导航栏，无需在每个页面重复引入 Header。
3.  **扩展性**：`createBrowserRouter` 为未来使用 React Router 6.4+ 的高级数据加载（Loaders/Actions）打下了基础。
4.  **性能优化**：懒加载 + Suspense 实现代码分割，提升首屏加载速度。

## 6. 开发建议

- **新增页面**：在 `src/pages` 下新建组件 -> 在 `src/router/index.tsx` 中使用 `lazy()` 导入 -> 添加路由配置。
- **修改导航**：在 `src/layouts/MainLayout.tsx` 的 `navItems` 数组中修改。
- **优化 Loading**：可以为不同页面定制不同的 Loading 状态（如骨架屏）。
